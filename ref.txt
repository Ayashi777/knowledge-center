Ок, зробив аудит коду з `knowledge-center-main.zip` і підготував план рефакторингу (з пріоритетами, щоб не “ламати все одразу”, а підсилювати додаток кроками).

---

## 1) Що зараз “болить” по архітектурі

### Монолітні файли (головний технічний борг)

* `App.tsx` ~617 рядків — одночасно: роутинг, auth-state, роль, модалки, CRUD по Firestore, навігація, UI-логіка.
* `components/Views.tsx` ~887 рядків — одразу `DashboardView`, `DocumentView`, `Pagination` і багато умовних гілок.
* `components/Modals.tsx` ~567 рядків — кілька модалок в одному файлі (складно тестувати, складно змінювати).

**Наслідок:** будь-яка правка викликає “хвіст” побічних помилок (те, що у вас регулярно відбувається останні дні — типова ознака).

---

## 2) Дані / Firestore: ризики і вузькі місця

### 2.1. Підвантаження всього та фільтрація на клієнті

`useDocuments.ts` робить `onSnapshot(collection(db, 'documents'))` і потім фільтрує/сортує все локально.

**Ризик масштабу:** якщо документів стане 300–2000+, буде:

* повільно на слабких пристроях,
* дорого по трафіку,
* багато ререндерів.

✅ Рефакторинг: винести “запити” у data-layer і поступово перейти на:

* `query + where + orderBy + limit` (серверна пагінація),
* або хоча б “ліниву” підгрузку і кешування.

### 2.2. Невизначені типи часу

У `types.ts`:

* `updatedAt: any; // Firestore Timestamp or Date`

**Наслідок:** баги в сортуванні/порівнянні дат і “невловимі” помилки в runtime.

✅ Рефакторинг: нормалізувати час до одного типу:

* або `Timestamp` всюди,
* або відразу конвертувати в `Date` при мапінгу snapshot.

### 2.3. Ролі/права: логіка розкидана

Є:

* `utils/auth.ts` (отримання ролі з Firestore),
* `auth.ts` (hardcoded permissions по ролях) — виглядає як легасі, але може впливати,
* плюс права доступу є в категоріях/документах.

**Наслідок:** важко гарантувати, що UI, правила Firestore і реальна поведінка збігаються.

✅ Рефакторинг: 1 “джерело істини” для RBAC:

* `permissions.ts` (чисті функції: `canViewCategory(role, category)`, `canDownloadDoc(role, doc)`),
* UI викликає тільки ці функції,
* правила Firestore/Storage відповідають тій же моделі.

---

## 3) Безпека: критичне зауваження

### Storage Rules зараз дуже відкриті

`storage.rules` дозволяє:

* `allow read, list: if true;` (всі файли всім, навіть гостям)
* `allow write` лише адмінам.

Якщо у вас можуть бути приватні/внутрішні файли — це **критичний ризик** (будь-хто з лінком може читати, а list дозволяє індексацію шляхів).

✅ Рефакторинг варіанти:

1. Мінімально: читання тільки для авторизованих (`request.auth != null`)
2. Правильно: читання залежить від прав на документ/категорію (складніше, але реально)
3. Компроміс: публічні файли зберігати в окремому префіксі `/public/**`, приватні — `/private/**` з різними правилами.

> Я не бачу у zip окремих `firestore.rules` — якщо їх реально немає в проєкті, це теж потрібно виправити (інакше доступи контролюються тільки UI, що небезпечно).

---

## 4) i18n: зараз “напів-готове”

В `i18n.tsx`:

* `export type Language = 'uk'; // Locked to Ukrainian for now`

Але структура документів уже мультимовна (`content: { [key in Language]?: ... }`), та в UI ви часто передаєте `lang`.

**Наслідок:** код ускладнений, але бізнес-цінності поки 0.

✅ Рефакторинг: або:

* чесно прибрати мультимовність з типів/даних (спростити),
  або
* розблокувати `uk | en` і довести до кінця (а тоді типи/контент мають сенс).

---

## 5) Пропозиція нової структури проєкту (рефакторинг без “переписати з нуля”)

### Крок 1 (швидкий, безболісний): “розрізати моноліти”

**Було**

* `App.tsx`
* `components/Views.tsx`
* `components/Modals.tsx`

**Стає**

* `src/app/App.tsx` (тільки роутинг + провайдери)
* `src/app/providers/AuthProvider.tsx`
* `src/app/providers/I18nProvider.tsx` (або залишити як є)
* `src/pages/DashboardPage.tsx`
* `src/pages/DocumentPage.tsx`
* `src/widgets/modals/LoginModal.tsx`
* `src/widgets/modals/DocumentEditorModal.tsx`
* `src/widgets/modals/UserEditorModal.tsx`
* `src/widgets/modals/CategoryEditorModal.tsx`
* `src/shared/ui/Pagination.tsx`

**Ефект:** менше конфліктів, простіше дебажити, простіше тестувати.

---

### Крок 2: Data-layer (Firestore ізолюємо від UI)

Додати шар:

* `src/shared/api/firestore/documents.repo.ts`
* `src/shared/api/firestore/categories.repo.ts`
* `src/shared/api/firestore/tags.repo.ts`
* `src/shared/api/firestore/users.repo.ts`

І UI більше не робить `setDoc/deleteDoc` напряму — тільки викликає методи репозиторію.

**Ефект:**

* ви прибираєте “хаос” з App/Views,
* централізуєте обробку помилок, логування, нормалізацію даних (Timestamp → Date).

---

### Крок 3: Єдиний модуль доступів (RBAC)

* `src/shared/lib/permissions.ts`

Там тільки чисті функції:

* `canViewCategory(role, category)`
* `canViewDocument(role, doc, category)`
* `canDownloadDocument(role, doc, category)`

**Ефект:** UI стає передбачуваний, зникають “дивні розбіжності”.

---

### Крок 4: Продуктивність (коли будете готові)

Поступова міграція `useDocuments`:

* спочатку кеш/мемо/менше перерахунків
* потім серверна пагінація
* потім (за потреби) окремі запити під фільтри

---

## 6) Полірування якості (дуже бажано, але після стабілізації)

### DX / Контроль якості

* ESLint + Prettier (щоб не ловити JSX-помилки типу `}` в JSX на білді)
* Валідація даних з Firestore (напр. zod) — ловить “биті” документи одразу
* Мінімальні тести на permissions + репозиторії (Vitest)

---

## 7) Рекомендований порядок робіт (щоб не зламати реліз)

1. **Розрізати файли** (App / Views / Modals) без зміни логіки
2. **Винести Firestore CRUD** у repo-шар
3. **Зібрати RBAC** в одному місці і підключити UI
4. **Підтягнути rules** (Storage + Firestore) відповідно до RBAC
5. Оптимізація запитів / пагінація

---

Якщо хочеш — наступним повідомленням я дам **конкретний “refactor checklist” по файлах** (що куди перенести, які імпорти змінити, які модулі створити), щоб ти або розробник могли робити це по пунктах і перевіряти після кожного кроку білд/деплой.
